// src/store/chatStore.ts
import { create } from 'zustand';
import { ChatSession, Message, LLMProvider } from '../types';

interface ChatStore {
  // State
  sessions: ChatSession[];
  currentSession: ChatSession | null;
  selectedProvider: LLMProvider;
  selectedModel: string;
  isLoading: boolean;
  error: string | null;

  // Actions
  setSessions: (sessions: ChatSession[]) => void;
  setCurrentSessionInStore: (session: ChatSession | null) => void;
  setSelectedProvider: (provider: LLMProvider) => void;
  setSelectedModel: (model: string) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;

  // Session Management Actions
  createSessionInStore: (sessionId: string, name?: string) => ChatSession;
  addMessageToStore: (sessionId: string, message: Message) => void;
  updateSessionNameInStore: (sessionId: string, newName: string) => void;
  deleteSessionFromStore: (sessionId: string) => void;

  // Local Storage Persistence
  loadSessions: () => void;
  saveSessions: () => void;
}

/**
 * Defines the available models for each provider.
 * This should be kept in sync with types.ts and the backend capabilities.
 */
const MODEL_OPTIONS: Record<LLMProvider, string[]> = {
  openai: ['gpt-4o', 'gpt-4-turbo', 'gpt-4', 'gpt-3.5-turbo'],
  anthropic: ['claude-3-opus-20240229', 'claude-3-sonnet-20240229', 'claude-3-haiku-20240307'],
  deepseek: ['deepseek-chat', 'deepseek-coder'],
  gemini: ['gemini-1.5-pro-latest', 'gemini-1.5-flash-latest', 'gemini-1.0-pro']
};

export const useChatStore = create<ChatStore>((set, get) => ({
  // --- Initial State ---
  sessions: [],
  currentSession: null,
  selectedProvider: 'deepseek', // Default provider on app load
  selectedModel: 'deepseek-chat',    // Default model for the provider
  isLoading: false,
  error: null,

  // --- Basic Setters ---
  setSessions: (sessions) => set({ sessions }),
  setCurrentSessionInStore: (session) => set({ currentSession: session }),
  setSelectedProvider: (provider) => {
    const models = MODEL_OPTIONS[provider];
    set({
      selectedProvider: provider,
      // Auto-select the first model in the list for the new provider
      selectedModel: models.length > 0 ? models[0] : ''
    });
  },
  setSelectedModel: (model) => set({ selectedModel: model }),
  setLoading: (loading) => set({ isLoading: loading }),
  setError: (error) => set({ error }),

  // --- Session Management Actions ---

  /**
   * Creates a new session object in the store after an ID has been generated by the backend API.
   * @param sessionId The ID received from the backend.
   * @param name Optional name for the chat; a default will be generated if not provided.
   * @returns The newly created ChatSession object.
   */
  createSessionInStore: (sessionId, name) => {
    const now = new Date();
    const defaultName = name || `Chat ${now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;

    const newSession: ChatSession = {
      session_id: sessionId, // Use the ID from the API
      name: defaultName,
      createdAt: now,
      messages: []
    };

    const { sessions } = get();
    // Add new session to the beginning of the array
    const updatedSessions = [newSession, ...sessions];

    // Limit the total number of sessions stored locally to prevent bloat
    const MAX_SESSIONS = 15;
    if (updatedSessions.length > MAX_SESSIONS) {
      updatedSessions.pop(); // Remove the oldest session from the end of the array
    }

    set({ sessions: updatedSessions });
    get().saveSessions(); // Persist changes to localStorage

    return newSession;
  },

  /**
   * Adds a message to a specific session.
   * @param sessionId The ID of the session to update.
   * @param message The Message object to add.
   */
  addMessageToStore: (sessionId, message) => {
    set((state) => ({
      sessions: state.sessions.map(session =>
        session.session_id === sessionId
          ? { ...session, messages: [...session.messages, message] }
          : session
      ),
      // Also update the currentSession object directly if it's the active one for instant UI update
      currentSession: state.currentSession?.session_id === sessionId
        ? { ...state.currentSession, messages: [...state.currentSession.messages, message] }
        : state.currentSession
    }));
    get().saveSessions();
  },

  /**
   * Updates the name of a specific session.
   * @param sessionId The ID of the session to update.
   * @param newName The new name for the session.
   */
  updateSessionNameInStore: (sessionId, newName) => {
    set((state) => ({
      sessions: state.sessions.map(session =>
        session.session_id === sessionId ? { ...session, name: newName } : session
      ),
      currentSession: state.currentSession?.session_id === sessionId
        ? { ...state.currentSession, name: newName }
        : state.currentSession
    }));
    get().saveSessions();
  },

  /**
   * Deletes a specific session from the store.
   * @param sessionId The ID of the session to delete.
   */
  deleteSessionFromStore: (sessionId) => {
    set((state) => {
        const remainingSessions = state.sessions.filter(s => s.session_id !== sessionId);
        let newCurrentSession = state.currentSession;

        // If the deleted session was the current one, switch to the most recent remaining session or null
        if (state.currentSession?.session_id === sessionId) {
            newCurrentSession = remainingSessions.length > 0 ? remainingSessions[0] : null;
        }

        return {
            sessions: remainingSessions,
            currentSession: newCurrentSession
        };
    });
    get().saveSessions();
  },


  // --- Local Storage Persistence ---

  /**
   * Loads all sessions from localStorage on application startup.
   * Also sets the most recent session as the current session.
   */
  loadSessions: () => {
    try {
      const stored = localStorage.getItem('chat-sessions');
      if (stored) {
        // Re-hydrate session objects, ensuring Date objects are correctly parsed
        const sessions: ChatSession[] = JSON.parse(stored).map((session: any) => ({
          ...session,
          createdAt: new Date(session.createdAt),
          messages: (session.messages || []).map((msg: any) => ({
            ...msg,
            timestamp: new Date(msg.timestamp)
          }))
        }));

        set({ sessions });

        // If sessions were loaded and no session is currently active, set the most recent one.
        if (sessions.length > 0 && !get().currentSession) {
            set({ currentSession: sessions[0] });
        }
      }
    } catch (error) {
      console.error('Failed to load sessions from localStorage:', error);
      // Optional: Clear corrupted storage to prevent repeated errors
      // localStorage.removeItem('chat-sessions');
    }
  },

  /**
   * Saves the current list of sessions to localStorage.
   * Truncates message history per session to prevent localStorage bloat.
   */
  saveSessions: () => {
    try {
      const { sessions } = get();
      // To prevent localStorage from getting too large, only save the last N messages.
      // The full history is maintained on the backend.
      const MAX_MESSAGES_PER_SESSION_IN_STORAGE = 50;
      const sessionsToSave = sessions.map(session => ({
        ...session,
        messages: session.messages.slice(-MAX_MESSAGES_PER_SESSION_IN_STORAGE)
      }));
      localStorage.setItem('chat-sessions', JSON.stringify(sessionsToSave));
    } catch (error) {
      console.error('Failed to save sessions to localStorage:', error);
    }
  }
}));